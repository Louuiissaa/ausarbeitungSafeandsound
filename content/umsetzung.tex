\chapter{Umsetzung} \label{sec:Umsetzung}

\section{Architektur}\chapterauthor{Louisa Pabst}
Auf Basis der Grundlagen und Analyse wird die Architektur des Systems erstellt.
In der Architektur werden alle wichtigen Entscheidungen, welche für die
Entwicklung des Systems relevant und von technischer Natur sind, berücksichtigt. Die Architektur dient als Grundlage für die darauffolgende Umsetzung.

\section{Raspberry Pi}

\subsection{Sensoren}
\begin{itemize}
	\item Kameramodul
	\item Temperatursensor
	\item Luftfeuchtigkeitssensor
	\item Luftqualitätssensor 
\end{itemize}


\subsection{Sensor Adapter}
Der Sensor Adapter ist notwendig, um die Daten aus den Sensoren auszulesen und anschließen abzuspeichern. Nachfolgend soll erklärt werden, wie die Sensoren verschaltet sein müssen, damit Eingangssignale ausgewertet werden können. 

\subsubsection{Fester/ Tür-Status}
Der Aufbau um eine Tür 

\subsection{Persistenter Speicher}
Basierend auf den Grundlagen soll eine relationale Datenbank zum Speichern der Sensorwerte genutzt werden. Dabei muss die Datenbank kompatibel mit dem Raspberry Pi sein, sowie möglichst ressourcenschonend agieren. \\Es ist nicht notwendig Daten über das Netzwerk in die Tabelle einzutragen, da alle Sensoren über den Raspberry eingelesen werden können und die Datenbank somit nur lokal verfügbar sein muss.  

Anforderungen:\\
-Lokal \\
-Schreibzugriffe über das Netzwerk\\
-Concurrent writers?\\
-Big Data -> wir haben nur kleine Datenmengen\\
-Embedded\\
-Small / Hardwareressourcen/ leichtgewichtig\\
-Portabilität\\
-User Management -> nicht notwendig\\
-Kompatibilität mit Raspberry\\

Daten nur speichern und nach außen verfügbar machen.

Vergleich in Datei schreiben, MySQL, SQLite\\
.
\subsubsection{SQLite}
Die SQLite Datenbank bietet für unsere definierten Einsatzzweck ausreichende Funktionalität an. Die Anwendung ist leichtgewichtig und läuft lokal. Außerdem verfolgt die Datenbank bei Transaktionen das ACID (atomic, consistent, isolated, durable) Prinzip. Datenbankzugriffe geschehen mit SQL. Alle Datenbanktabellen sind lokal in einer Datenbank-Datei gespeichert. Dies kann somit einfach kopiert werden, falls ein neuer Raspberry zum Einsatz kommen sollte.\\
Da jeder Raspberry seine eigene Datenbank besitzen sollte, damit keine privaten Daten zentral auf einer Datenbank abgelegt werden eignet sich SQLite ebenfalls gut. 
*******
https://www.sqlite.org/features.html

hat keine Server prozess, zero-configuration, trasaction SQL, read writes directly into ordinary disk file
single disk file 
ACID
Full featured SQL
cross platform
standalone command line interface

content BLOB -> Dokument kann in db abgelegt werden


\subsection{Datenbankschema}

\subsection{Flows Node-Red}
\begin{figure}
	\centering
	\includegraphics[scale=0.7]{images/tempIntFlow}
	\caption{Beispiel: Temperatur Intervall abfragen}
	\label{flow:TempInt}
\end{figure}
Damit der User nicht nur basierend auf der Rule Engine Sensordaten geliefert bekommt, wird über Node Red eine \acf{API} erstellt, die jederzeit angesprochen werden kann um die neusten Daten anzuzeigen. Die \ac{URL} setzt sich aus der \ac{IP}-Adresse des Raspberry's dem Port 1880 für Node-Red und einen relative Pfad zusammen. 
\\Die \ac{API} hat folgenden Schnittstellen, die über \ac{HTTP}-Get Request angesprochen werden können:
\begin{itemize}
	\item \textbf{/temp}: Diese Route liefert dem User den aktuellen, vom Temperatur- \& Luftfeuchtigkeitssensor gemessenen Wert zurück. 
	\item \textbf{/tempInt}: Um sich den Temperaturverlauf innerhalb eines begrenzten Zeitraums sich anzeigen zu lassen, kann diese Route angesprochen werden. Dabei müssen an den relativen Pfad zwei Parameter, \enqoute{from} und \enqoute{to},  gesetzt werden.  Beiden Parametern muss ein Datum in der Form \enquote{dd.mm.yyyy} übergeben werden. \\Die Anfrage setzt sich dann aus der \ac{IP}-Adresse, dem Port, sowie dem relativen Pfad zusammen und hat beispielsweise folgende Form: \enquote{192.168.0.100:1880/temInt?from=10.05.2017\&to=25.05.2017}
	\item \textbf{/window}:
	\item \textbf{/picture}:
	\item \textbf{/motion}:
	\item \textbf{/mqgas}:
	\item \textbf{/gasInt}:
	\item \textbf{/temp}:
\end{itemize}

Außerdem werden noch Flows benötigt, die innerhalb eines definierten Intervalls die aktuellen Sensordaten abfragen und anschließen in der entsprechenden Datenbanktabelle abspeichern. In ABBILDUNG XX ist beispielhaft aufgezeigt, wie der Datenfluss in Node-Red modelliert ist, damit alle 5 Minuten ein Datenbankeintrag erstellt wird. 




\section{Grafische Benutzeroberfläche}\chapterauthor{Louisa Pabst}
Als grafische Benutzerschnittstelle für das in dieser Arbeit erläuterte System wird eine ortsunabhängige Lösung entwickelt (F-10.2). Um eine Ortsunabhängigkeit gewährleisten zu können, bietet es sich an ein mobiles Endgerät zu entwickeln. Es wurde  entschieden als Benutzerschnittstelle eine Android App zu nutzen, aus dem Grund, dass Android den höchsten Endkundenabsatz besitzt \cite{statista:marktanteileandroid} und dadurch eine größere Maße erreicht werden kann.
\subsection{Rule Engine}
Vor Beginn der Entwicklung muss die Struktur von Regeln analysiert werden. Eine Regel besteht aus einem Wenn-Teil und dem Dann-Teil. Der Wenn-Teil wiederum kann aus mehreren einzelnen Wenn-Teilen zu einem übergreifenden Wenn-Teil zusammengefasst werden. Das Zusammenfassen mehrerer Wenn-Teilen führt zu mehr Regelmöglichkeiten. Der gleiche Grund kommt bei dem Dann-Teil zum Tragen. Gerade im Hinblick auf die Integration von weiteren Akteuren (F-60.2) ist es sinnvoll mehrere Akteure innerhalb eine Regel auslösen zu können.\\
Ein einzelner Wenn-Teil der Regel besteht aus einem Datentypen, Vergleichsoperator/en, Vergleichsdaten und einer Konjunktion zu einem anderen Wenn-Teil. Um dem Nutzer eine intuitivere Anwendung bieten zu können, werden Vergleichsoperatoren in Regeln angeboten, die aus zwei Operatoren bestehen. So können Vergleichsoperatoren, wie ``zwischen'' gewährleistet werden. Ein Wert ist dann zwischen zwei Werten, wenn der Datenwert größer als Vergleichswert 1 und kleiner als Vergleichswert 2 ist. Innerhalb der Rule Engine wird dementsprechend zwischen klassischen binären Operatoren und zusammengesetzten binären Operatoren unterschieden. Binäre Operatoren vergleichen zwei Werte miteinander QUELLE.\\
Die Rule Engine wird nach den Anforderungen aus Kapitel \ref{sec:Anforderungen} entwickelt. Demnach muss die Rule Engine dem Nutzer ermöglichen dynamisch Regeln hinzufügen zu können oder wieder zu löschen (F-30.1). Grenzwerte oder Wertebereiche kann der Nutzer für die erfassten Datentypen (F-10) selbst bestimmen (F-30.2). Des Weiteren soll die Rule Engine zeitliche Aspekte in den Regeldefinitionen einbinden können. Der Nutzer kann demnach zeitliche Intervalle festlegen, in denen ein Wert oder Wertebereich gehalten werden soll. Die Definition von Datenabhängikeiten kann von der Rule Engine verarbeitet werden, um optimalere Aktionen auslösen zu können (F-30.5).\\
Es werden mögliche Rule Engines recherchiert, die die gestellten Anforderungen erfüllen. Dabei wurden nur Rule Engines betrachtet, die in Android genutzt werden können, sowie welche mit regelmäßigen Releases. Aus der Recherche haben sich folgende Rule Engine Bibliotheken ergeben:
\begin{itemize}
	\item Easy Rules \cite{github:easyrules}
	\item OpenRules \cite{openrules}
	\item RuleBook \cite{github:rulebook}
\end{itemize}
Diese Rule Engines bieten gute Möglichkeiten Regeln zu erstellen und diese zu überprüfen. Regeln für bestimmte Werte können zur Laufzeit hinzugefügt werden. Was mit Hinblick auf Sensorenerweiterung durchaus Sinn macht. Jedoch muss jede Regel hartcodiert vor der Laufzeit in die Rule Engine hinzugefügt werden. Das ist ein entscheidener Nachteil dieser Rule Engines. Durch die Recherche konnte keine Engine gefunden werden, die eine dynamische Erstellung von neuen Regeln über die Oberfläche ermöglicht. Die Definition neuer Regeln durch den Nutzer ohne den Quellcode zu verändern, ist jedoch eine essentielle Anforderung. Aus diesem Grund wurde sich dafür entschieden, eine Rule Engine selbst zu implementieren.\\
Bei der Implementierung der Rule Engine wurden die Ergebnisse der Recherche miteinbezogen. Vor allem an die Struktur der Regeln zu ihren Wenn- und Dann-Teilen der Regel Engine RuleBook wurde bei der Implementierung betrachtet.\\
Für die Strukturierung der Rule Engine wurden mögliche Lösungswege betrachtet. Eine Möglichkeit wäre jede Regel als Java-Klasse zu erstellen. Jede spezifische Regel wurde dann von der Klasse Regel erben, sodass die Haupteigenschaften in jeder Klasse erhalten sind. Um dem Nutzer zu ermöglichen eine neue Regel zur Laufzeit hinzuzufügen, müsste eine neue spezifische Regel-Klasse zur Laufzeit hinzugefügt werden.\\
Das Hinzufügen von Klassen zur Laufzeit hat vor allem vier Nachteile, die in unserem Kontext relevant sind. Der erste Nachteil ist die Umgebung, in der der Quellcode ausgeführt werden muss. Zur Kompilierung zur Laufzeit muss die Umgebung eine JDK besitzen. Ohne JDK ist das Hinzufügen von Klassen zur Laufzeit nicht möglich. Ein weiterer Nachteil ist die Komplexität. Durch das Kompilieren von Klassen zur Laufzeit entsteht eine erhöhte Komplexität, aus der auch der dritte Nachteil resultiert. Die Geschwindigkeit der Applikation wird beeinträchtigt. Gerade bei einer mobilen Applikation möchte ein Nutzer nicht lange auf das Ergebnis warten. Der letzte entscheidene Nachteil ist die Sicherheit. Wenn dem Nutzer die Möglichkeit gegeben wird zur Laufzeit eine Regel hinzuzufügen, kann dieser versuchen Schadcode einzubauen. Bei erfolgreicher Schadcode-Einbettung ist die gesamte Applikation stark beeinträchtigt.\\
Eine weitere Möglichkeit eine Rule Engine zu implementieren ist mit Hilfe eines JavaScript Interpreters. Die Regel wird dabei in JavaScript Code abgespeichert. Bei Ausführung der Rule Engine wird dann der JavaScript-Code interpretiert. Auch bei dieser Möglichkeit der Umsetzung ist ein entscheidener Nachteil, die Sicherheit. Es muss verhindert werden, dass der Nutzer bei der Spezifikation der Regel Schadcode einfügen kann, die dann durch den Interpreter ausgeführt wird.
Leichtgewichtig durch JavaScript Interpreter J2V8 QUELLE

- User kann in einer Erweiterung Regeln definieren durch JavaScript direkt
- Wenn neue Datentypen hinzugefügt werden sollen, müssen diese nur in NodeRed und auf der UI direkt hinzugefügt werden. Die Rule Engine kann mit neuen Datentypen ohne Quellcode Veränderung umgehen.
- Mit JavaScript kann leicht Kontextdaten hinzugefügt werden, wie aktuelle Uhrzeit etc.

%- andere Möglichkeiten:
%	- Eigene Klasse je Regel, die von der Hauptklasse Regel erbt. --> Nachteil Neues Hinzufügen von Regeln über den Nutzer nicht ohne Quellcode Änderung möglich --> gleiches Problem wie bei den bereitserwähnten Rule Engine Bibliotheken
%	- Zusammenbasteln eines Strings das die Wenn-Kondition beschreibt --> Problem: Auswertung des IfStetements nach Einfügen aller Variablen
%	- JavaScript Interpreter ermöglicht Auswertung des IfStatements zur Laufzeit mit Einfügen der übergebenen Daten vom Raspberry Pi
%--> Sequenzdiagramm - Aufrufe von Übermittlung der Daten bis Auslösung der Aktion

%- Warum keine RuleEngine Bibliothek nutzen?
%-mögliche Rule Engines: es wurden nur RuleEngines betrachtet, die in Android genutzt werden können
%- Easy Rules
%- OpenRules
%- Dredd
%- RuleBook
%-Vorteile:  
%- Nachteile bzw. Vorteile von diesen Engines
%- Warum keine bekannt Rule Sprache nutzen um Regeln zu definieren? - RuleML

\subsection{Daten Anzeige}